	Есть позитивное тестирование (доказать что ПО работает)
	Негативное тестирование (доказать что не работает)

	Качество получается благодаря менеджменту, который состоит из обеспечения и контроля качества. Все вместе = тестирование.

	Тестирование - процесс связанный с планированием, подготовкой, оценкой ПО и связанных продуктов, чтобы удостовериться что они удовлетворяют требованиям, чтобы показать что они выполняют свои функции и чтобы выделить баги.
	Качество - уровень до которого компонент система или процесс должны выполнять определенные требования и/или пользовательские/клиентские нужды и ожидания.
	Менеджмент качества - координированные действия для направления и контроля организации касательно качества.
	Обеспечение качества - часть менеджмента, фокусируется на предоставлении гарантии что требования качества будут выполнены.
	Контроль качества - оперативные методы и действия, часть менеджмента, фокусируется на выполнении требований качества.

	Дефект - когда ожидание не совпадает с фактом. Ожидания берутся из требований, факт - из наблюдения за работой приложения.

	Чеклист - список с набросками идей. 
	Тесткейс - каждый пункт чеклиста может создать один или несколько тесткейсов. Они уже требуют определенного подробного оформления.
	Тестсьют - когда тесткейсы проходят через некоторую организацию по критериям, объединяются в группы итд.
	
	Методологии и то где в них находится тестирование:
	1. Водопад, тестирование в середине проекта, в модели повторений нет, все строго по прямой, ошибки накапливаются, не исправляются, модель только для непоровотливых стабильных проектах.
	2. V-модель, все те же стадии но в виде V, на стадиях смотрят в будущее и думают наперед, проблема в том, что непонятно, какая дельта времени между стадиями, т.к. в будущее в несколько лет не заглянешь. В тестировании точнее подчеркнули что тут улучшается немного результат.
	3. Итерационная инкрементальная модель, первая узаконила идею повторения действий, стадии проходятся несколько раз итерациями, возможность исправить упущенные ошибки, тестирование в каждой стадии, ориентирована на крупные проекты, но нужно много бюрократии, дорого.
	4. Гибкая модель, для маленьких команд, есть некий набор требований (беклог), выбирается подмножество (беклог спринта), морозится, его трогать нельзя, пока не закончится спринт, в его рамках проводятся суточные итерации, по итогам появляется деливерабл который можно показать. Тестирование тут тоже находится везде.
	5. ИТОГ: Если модель не итерационная, то тестирование между стадиями, в итерационных тестирование и между и в самих стадиях.

	Жизненный цикл тестирования ПО:
	1. Общее планирование и анализ требований, нужно понять что тестировать и как, есть ли ресурсы, все ли хорошо с требованиями.
	2. Критерии приемки, как оцениваем продвижение плана, когда начинать, завершать, паузить тестирование. 
	3. Стратегия, как наилуч образом с минимал потерями добраться до желаемого результата. Много менеджерской работы.
	4. Создание тесткейсов, пересмотр, улучшение, все артефакты задействованы.
	5-6. Выполнение тесткейсов и написание отчетов о дефектах(багрепорты). 
	7-8. Анализ о результатах тестирования и формирование отчетности.

	Классификация видов тестирования:
	Тестирование делится на функциональное/нефункциональное тестирование.
	Функциональное необходимо для проверки функциональных требований (что приложение делает).
	Нефункциональное для проверки нефункц требований типа производительность безопасность итд.
	
	Тестирование делится на:
	1. По выполнению кода: Статическое и динамическое.
Статическое без запуска кода(документация, кодревью), динамическое - с.
	2. По доступу к коду и архитектуре: вайтбокс, блекбокс, грейбокс.
Вайтбокс - физический, юридический, когнитивный(понимание что с коде написано) доступ к коду. Если что-то из трех не выполняется - белый ящик не получается.
Блекбокс - работа с точки зрения конечного пользователя, какой-то из типов доступа недоступен или нам не нужен.
Грейбокс - комбинация, часть системы по белому ящику, часть по черному.
	3. По уровню детализации: модульное, интеграционное, системное тестирование. В процессе тестирования двигаемся именно по этому порядку, в процессе нахождения причин дефектов - по обратному.
	4. По уровню автоматизации: мануальное и автоматическое.
	5. По важности функций для пользователя: смоуктест, критический путь, расширенное.
Смоуктест - главные функции, без которых приложение не будет нужно. 
Критический путь - тоже важные, но не критичные.
Расширенное тестирование - какие-нибудь мелкие функции.
	6. По способу отношения к приложению: позитивное (доказать работоспособность) и негативное тестирование (обнаружить дефекты).
У всех тестов ожидаемый результат - корректная работа.

	Тестовое планирование - процесс установки или обновления тестового плана. Тестовый план - документация, описывает идеи и цели тестирования, которые надо достичь и способы и расписание их достижения, организованное для координации процессов тестирования.
	Цели и задачи планирования:
	1. Что именно предстоит сделать? Как много, как сложно, стоит ли разбить на фрагменты.
	2. Есть ли ресурсы? Где их взять? Время когда ресурсы будут доступны.
	3. Идея планирования времени и ключевых точек. Когда что должно быть готово.
	4. Работа с рисками и контрмеры к рискам.
	5. Распределение обязанностей и ответственностей.
	6. Координировать взаимодействие между отдельными людьми или группами.

	Тестплан помогает добиться лучших результатов с меньшими затратами, оптимизация ресурсов без пустой траты, позволяет увидеть прогресс на любом моменте, понять что делать в любой ситуации, добиться лучшего понимания и кооперации между людьми.


	 Ключевые секции тестового плана.
	1. Масштаб и главные цели проекта - похожа на бизнес требования, но тут направление на самые важные задания.
	2. Перечень тестируемых требований - список функциональных\нефункциональных тестируемых требований.
	3. Требования которые НЕ тестируются - прописываются еще и причины, по которым не тестируют.
	4. Тестовая стратегия и подходы - показывает методы, типы тестирования, технологии, инструменты.
	5. Критерии - показывают, насколько продвинулись в достижении и можем ли мы выполнять какие-то действия (принять билд, начать/приостановить тестирование итд)
	6. Ресурсы - ПО, АО, люди, финансы, какой софт используется.
	7. Расписание - календарь с целями.
	8. Роли и ответственности - список главных ролей проекта и их ответственности.
	9. Оценка рисков - прописать уникальные риски для проекта, как их увидеть и что с ними делать.
	10. Документация - список имеющихся документов с деталями о том кто их подготавливает, когда, как.
	11. Метрики - На них базируются критерии, они выражаются в виде формул, чтобы увидеть точный прогресс, типа формул процента успешно выполненных тесткейсов.

	Требования - что-то что должно быть реализовано.
	Документация бывает как минимум продуктной и проектной.
	Со временем растет стоимость исправления проблем.
	3/4 дефектов приходятся на этапе документации.

	Способы сбора требований:
	1. Интервью - самый распространенный. Две роли - интервьюер и интервьюируемый. Не нужны технологии, все понимают концепт, есть разные вариации, НО! нужно визуальное представление, нужно какое-то время для переработки результатов интервью, на интервьюере вся ответственность.
	2. Митинги (и брейншторм) - участвует несколько людей с одной ролью.Все люди получают всю инфу сразу, митинги быстрее переписок, коллективное мышленые приходит к эффективным результатам, НО! очень много времени занимает, тяжело собрать всех людей сразу, интенсивные митинги становятся скучными и неэффективными.
	3. Анкетирование - получить инфу от многих респондентов с интересными результатами, большое покрытие аудитории, легко и круто обработать информацию, можно анкетирование повторить через время, НО! если плохо сформулировать анкетирование можно не получить данные или получить неправдоподобную инфу.
	4. Наблюдение - показывает вещи которые не услышишь. Можно собрать критически важные детали, более объективный, можно пересмотреть подход к решению задачи заказчика, НО! тяжело организовать, опытных наблюдателей очень мало, если неверно организовать дает много плохой инфы.
	5. Прототипирование - выступает как источник новой инфы и нечно материальное. Предпочитается больше остальных, дает больше данных чем словесное описание, НО! занимает время, жалко потом отбрасывать, очень важно вовремя остановиться.
	6. Моделирование - похоже на 5., но не обязательно является чем-то физическим, более абстрактная. Может быть математической или вычислительной моделью или подобным. Делает сложные вещи более понятными, может выявить скрытые особенности проекта, позволяет увидеть хороша ли идея в принципе, НО! требует опыта и знаний, инструментов, неверное построение дает плохую инфу, их тяжело понять чем прототипы.
	7. Анализ документации - чтение стандартов, мануалов итд. Не нужны инструменты, просто чтение, которое делает более хорошим специалистом, НО! с новыми данными появляются новые вопросы, есть вероятность пропустить какой-то дефект или создать его.
	8. Работа с фокусными группами - более тесное взаимодействие с конечными пользователями, дискуссии. Получаем много инфы от реальных пользователей, более глубокое вовлечение, не только сбор инфы но и изменение мнение пользователя, НО! надо выбрать правильных людей, правильно собрать эту группу, надо подписывать соглашение о неразглашении.
	9. Описание или самопереписывание - инфы которую получили в процессе работы с остальными подходами. Приводится к универсальному формату. НО! надо избегать добавления собственных идей, разделять свои предложения и нужды заказчика.


	Уровни и типы требований:
	1. Бизнес требования - показывают цель, задачу продукта. Оформляются в документе Прожект вижн и лимитейшнс.
	2. Юзер требования - описывает что пользователи в разных ролях могут делать в системе и как она будет на это реагировать. Используются юзкейсы но редко, чаще юзерсторисы ("Я как _ делаю _ чтобы _")
	3. Тип Функционального требования - что система должна делать
	Нефункциональное требование - как она должна это делать (вопросы удобства использования, производительности итд.)

	Свойства хороших требований:
	1. Атомарность (Структурированность) - требование атомарное если описывает одну ситуацию, его нельзя разбить на части, без потери завершенности.
	Как обнаружить проблему атомарности: если кажется что требование можно разбить на несколько - его нужно разбить на несколько.
	Как починить проблему: Переписать требование, разделить.
	2. Завершенность - вся информация предоставлена, ничего не упущено "потому что всем и так ясно", все расписано.
	Как обнаружить проблему завершенности: задавай вопросы, используй графические репрезентации.
	Как починить: дописывание.
	3. Непротиворечивость - отсутствие внешних и внутренних противоречий между требований, функционалом итд.
	Как обнаружить проблему: иметь хорошую память или графическое представление системы.
	Починка: уточнить противоречие и исправить.
	4. Недвусмысленность, ясность - описывание без субъективных толкований, жаргона, неочевидных аббревиатур, размытых понятий.
	Как обнаружить: искать специфические фразы, писать чеклисты.
	Как чинить: использовать числа и формулы, строгие термины и стандарты.
	5. Необходимость и актуальность - отсутствие идей "а почему бы и нет", неправильно расставленных приоритетов.
	Как обнаружить: пересмотр набора требований с заказчиком.
	Как чинить: перепись после пересмотра если нужно.
	6. Техническая выполнимость - идея укладывается в бюджет, расписание, ресурсы проекта, важна и нужна, и вообще относится к самой системе.
	Как обнаружить: иметь опыт в области или консультироваться.
	Как починить: обсуждать и менять либо требования либо проект.
	7. Прослеживаемость вертикальная - показывает связь между уровнями документации, и горизонтальная - показывает связь между требованиями на одном уровне. Наличие идентификаторов, структуризации, референсов.
	Как обнаружить: задать вопрос "откуда это появилось? на что влияет"
	Как исправить: добавить теги, закладки, идентификаторы итд.
	8. Модифицируемость - легкость изменения отдельных или нескольких требований, зависит от прослеживаемости, атомарности.
	Как обнаружить: нет прослеживаемость - нет модифицируемости.
	Как чинить: перепись с целью повышения прослеживаемости.
	9. Ранк по важности, стабильности, срочности. Важность показывает, насколько конечный успех зависит от реализации этого требования. Стабильность показывает вероятность того что требование в ближ. будущем не изменят. Срочность показывает что нужно сделать раньше а что позже.
	Как обнаружить: увидеть отсутствие ранка, проводить ревью периодично.
	Починка: Исправлять по ходу ревью.
	10. Корректность и проверяемость - если все прошлые типы выполняются корректно и отвечают требованиям. ГЛАВНЫЙ ТИП.
	Как обнаружить: рассматривать как общая интегральная проблема, если с ней что-то не так - с прошлыми типами что-то не так.
	Починка: Чинить остальные типы, опечатки, куски требований.

	
	Техники тестирования требований:
	1. Пирревью - взаимный перепросмотр, когда продукт ревьюируют другие люди с той же квалификацией. Делится на три уровня: беглый перепросмотр от коллег, технический перепросмотр от разных специалистов, формальная инспекция с тщательным перепросмотром от многих специалистов.
	2. Задавание ПРАВИЛЬНЫХ вопросов.
	3. Написание чеклистов, где можно задать себе вопросы, выписать идеи.
	4. Визуализация - диаграммы майндмапы графы итд.
	5. Моделирование и прототипирование - помогает собрать и улучшить требования.
	


	Чеклист - набор идей, заготовка того, что будем делать. Для ускорения, систематизации, они потом переделываются в тесткейсы.

(Как бы я протестировала старую задачу на треугольник Гленфорда Майерса.
1.Проверка основного функционала: ввести числа (3,5,2), (3,3,6), (3,3,3).
2.Проверить ответ системы на необычный ввод (0,0,0), (-5,-2,0), 3.(999999999999,9999999999,0), (999999999999999,0,0),4.(999999999999,99999999999,9999999999999).)
5.Проверить ответ системы на вообще не числа: (а,б,с), (!,!,%) итд.
МОЙ ВАРИАНТ ПОХОЖ НА ВАРИАНТ САМОГО МАЙЕРСА!!!!:) )

	Чеклисты надо писать! Так не забудешь.
	Начинай с простых идей! Сначала тестируем базовый функционал.

	Техники написания чеклистов:
	1. Разделение приложения на части, подчасти, подподчасти.
	2. Сценарии и действия пользователя.
	3. По предметной области.
	4. По специфическим целям и критериям качества.
	НЕ НАДО:
	1. Напрямую по требованиям
	2. Напрямую по интерфейсам

	Базовые техники тестирования:
	1. Использование классов эквивалетности и граничных условий. Класс эквивалентности - набор данных которые трактуются одинаково и приводят к одинаковому результату. Граничные условия - точки где один набор данных переходит в другой.

ЗАДАЧА: проверить юзернейм.(3-20 символов, можно цифры, _, англ буквы.)
Тестирование:
1. осн. функционал (должно быть TRUE): Ivan, ivan, IVAN, 123, ____, ivan123, ivan_, ivan123_, 123_
2. остальное (FALSE): ив, иван, 12, iv, !, ivan!, ivaaaaaaaaaaaaaaaaaaaaaaaaaaan9999999.
КАК ЛУЧШЕ БЫЛО ЕЕ РЕШИТЬ (хотя у меня технически сделано похоже)
1. Проверка длины (валид от 3 до 20, невалид 0-2, 21+)
2. Проверка допустимых символов ( валид: A-Z, a-z, цифры, _; невалид: остальные)
итак:
1. Длина валид, символы валид:
ABC, WFEWFEWFEWFEWFSFDSFD, abc_12_def
2. Длина невалид, символы валид:
AA, {empty}, ААААААААААААААААААААААААААААААААА
3. Длина валид, символы невалид: Asbc#23456$@!
Нет смысла брать все невалиды, так непонятно на что среагировала система.

	2. Функциональный подход - думать о функциях, действиях, работе пользователя. Например, есть две даты начала и конца отпуска. Есть ли специальные требования для них? Что если ввести что-то невалидное? Можно ли указать даты из прошлого? Что если даты одинаковые?


	ТЕСТКЕЙС - список с предварительным условием, входными данными, действиями, ожидаемыми результатами, целью (это ключевые поля).
	Ключевые поля:
	1. ID - уникальность и осмысленность.
	2. Приоритет - ABCDE или 12345 или словами.
	3. Идентификатор требования - часто ссылка, по какому требованию тесткейс.
	4-5. Модуль и подмодуль - НЕ действия, части и подчасти приложения. (Модуль "дыхательная система", подмодуль "легкие", НЕ "дышать")
	6. Заглавие теста - основная идея, суть теста.
	7. Некоторые приготовления к тесту (опционально) - выполняются до теста.
	8. Шаги
	9. Желаемые результаты - для каждого шага свой результат.

	При написании тесткейса АКТИВНЫЙ ЗАЛОГ и простые фразы в шагах.
	"Нажать на кнопку "Открыть""
	Объективное описание ожидаемых результатов.
	"Появится лейбл "Новый документ"".
	Пишите просто, с точными именами элементов, не надо объяснять примитивные вещи.

	Свойства качественных тесткейсов (почти те же что и у требований):
	1. Баланс нахождения между излишней специфичностью и общностью.
	Слишком специфичный повышает шанс упустить дефект и занимает время на написание.
	Слишком простой может быть сложным для новичков и тяжело понять идею.
	Как бороться: Не привязываться к конкретным значениям, четко знать как проверить результат, если нужны какие-то конкретные проверки конкретеых чисел, указать их отдельно.
	2. Баланс между излишней простотой и сложностью.
	Простой тесткейс - оперирует с одним объектов и имеет мало действий, его легко понять и выполнить, найденные дефекты легки и очевидны, излишне простой тест бесполезен.
	Сложный - несколько равных объектов и много нетривиальных действий, больше шанс что-то сломать, больше похоже на работу настоящего пользователя, разработчики редко такое проверяют, но излишне сложные занимают много времени написания и поддержки.
	3. Либо независимы либо обоснованно связаны.
	Независимый кейс - это стандарт, он не отсылается ни к какому другому кейсу и к нему никто не отсылается, их просто выполнять в любом порядке, легко объединять в сценарии, работает если какой-нибудь другой тест завален. НО больше приготовлений, больше шагов, часто появляется избыточность.
	Зависимый кейс - имеет референсы и цепочки тесткейсов, меньше приготовлений и шагов, начинается там, где заканчивается прошлый тест. НО тяжелее поддерживать, структура фиксированная и негибкая, и если один тест завалится - завалятся все после него.
	4. Хороший тесткейс имеет высокую вероятность обнаружения дефекта5.
	5. Хороший тесткейс следует единой логике и своим целям без отступлений.
	6. В хорошем тесткейсе нет лишних шагов.
	7. Хороший тесткейс старается минимизировать избытычность по отношению к другим кейсам.
	8. Хороший тесткейс делает найденные дефекты очевидными.
	9.Хороший тесткейс (даже сложный) может выполнять какие-то простые действия.

	

	Тестсьют - несколько отдельно взятых тесткейсов для какой-то общей цели или на общей базе, чтобы легче с ними работать.
	Тестсьют есть связанный и несвязанный.
	Несвязанный легче собрать, выполнять в разном порядке, они работают если один из них завалился, но возможна избыточность и тяжело эмулировать пользовательские сценарии.
	Связанный ровно наоборот, меньше приготовлений и шагов, идет цепочкой, легко эмулировать пользователя, но если один завалится - остальные после него заваливаются тоже.
	Для создания хороших тесткейсов важно задать вопросы и получить ответы на :
	ЧТО именно ожидается (результат для пользователя)?
	КТО наш пользователь?
	насколько это ВАЖНО?

	Зацикленные символические ссылки - возникает, когда символическая ссылка содержит путь, который непосредственно или косвенно указывает на саму себя. Например, если символическая ссылка A указывает на файл B, который в свою очередь является символической ссылкой, указывающей на файл A, то это создает цикл в структуре ссылок.

	Смертные грехи тестирования:
	1. Ложнопозитивные тесты - успешно проходят когда должны выдавать ошибку(маскируют ее)
	2. Слепые тесты - идут по мистической логике, делают сложные вещи ради ничего.
	3. Мусорные тесты - Анализируют малюсенькое поведение приложения (которое уже скорее всего было проверено другими тестами)

	Как надо тестировать:
	1. Типичные операции пользователей
	2. Полезные свойства приложения и как его можно сломать.
	
	ЧЕТЫРЕ ВОПРОСА ДЛЯ ПОВЫШЕНИЯ КАЧЕСТВА ТЕСТА:
	1. ЧТО передо мной?
	2. КТО это использует и для ЧЕГО? ( можно уже провести исследовательское тестирование)
	3. В каких конкретно ньюансах это используется? (Позитивное тестирование)
	4. Как это может сломаться? (Негативное тестирование)
	 

	ОТЧЕТЫ О ДЕФЕКТАХ:
	Отчет о дефекте - описывает факт возникновения, суть, статус, итд.
	Отчет следует логике: все подробно, вся информация предоставлена, правильно указана важность и срочность, он должен помочь разработчику починить проблему.
	Плохой отчет о дефекте: мало важных деталей, приходится долго читать и понимать, заставляет разработчика переделывать работу тестировщика.
	До написания отчета задай вопросы:
	1. Что я сделал? > Шаги вопроизведения
	2. Что я получил? > Актуальный результат
	3. Что я должен был получить? > Ожидаемый результат.
	Жизненный цикл дефекта:
	1. Дефект в состоянии сабмита
	2. Назначение ответственного за устранение
	3. Починка
	4. Проверка починки и Закрытие
	5. Открыт снова (если все-таки не починен), затем 2.
	6.Дефект из любого состояния может быть рекомендован к отклонению и отклонен
	7. Отложение дефекта если работа с ним неэффективна.

	Поля отчета о дефекте (ключевые):
	1. ID - уникальный и имеет значение
	2. Краткое описание - должно предоставить ответы на что произошло где и при каких условиях, предоставить много информации, быть кратким, сформировать так, чтобы оно не выглядело дубликатом. Часто заполняется последним.
	3. Подробное описание - детальное описание дефекта, ожидаемый результат, фактический, ссылка на требование.
	4. Шаги по воспроизведению - максимально подробно описать шаги по получению дефекта, потом описывается сам баг еще раз.
	5. Воспроизводимость - "всегда" и "иногда". Как часто воспроизводится эффект.
	6. Важность - значение ущерба фактом существования дефекта. 
	7. Срочность - как быстро нужно устранить, зависит целиком от ситуации.
	8. Лейблс/Теги/Симптом - с чем связан дефект, общее какое-то слово.
	9. Возможность обойти дефект с получением желаемого результата - да/нет.
	10. Комментарии - опционально, может иметь полезную инфу для исправления.
	11. Вложения - опционально, Скрины, логи, итд.

	Типичные ошибки создания отчетов:
	1. Мало информации для понимания и устранения дефекта.
	2. Нахождение "Дефекта" в той функциональности которая не была готова к тестированию.
	3. Предоставление некорректной информации
	4. Сленг или жаргон
	5. Критика чьей-то работы
	6. Не предоставление критически нужной детали для воспроизведения дефекта.
	7. Неверное выставление важности и срочности
	8. Написание отчета расплывчато, грамматически некорректно.
	9. Не предоставление необходимых вложений.
	10. Тестер не убеждает команду в опасности дефекта.
	
	Как писать хороший отчет:
	1 Описание даже самых малейших деталей.
	2. Детали должны быть во ВСЕХ полях, даже если с повторениями.
	3. Описывать даже самые базовые действия.
	4. Указать ссылку на требования если подобные есть
	5. Указать окружение, где обнаружен дефект
	6. Выключаем эмоции.
	7. Если дефектов несколько - для каждого разный отчет. НО если дефект ОДИН в нескольких местах, то можно сделать один отчет.
	8. Анализ первопричин возникновения проблем. Если есть опыт, можно и предложить способ решения проблемы.
	9. После нахождения и анализа дефекта сразу же запиши его.
	10. Анализируй самые критические последствия дефекта.


	ОТЧЕТ О РЕЗУЛЬТАТАХ ТЕСТИРОВАНИЯ - документация с итогами некоторого периода действия тестировщиков. Это база для планирования следующей итерации и надежный источник информации для ключевых лиц проекта.
	
	Приципы создания отчета:
	1. Всегда есть расписание выхода отчета.
	2. Обычно за это отвечает тестлид
	3. Если надо, отчет можно обсудить
	4. Отчет создается на базе какого-то шаблона
	
	Кому и зачем нужен отчет:
	1. Ключевые люди и Заказчик
	2. Проект менеджер
	3. Тимлид разрабов
	4. Тимлид тестеров
	 
	Секции отчета о результатах тестирования:
	1. Краткое описание - выжимка самого важного на проекте, чтобы ключевые люди из нее получили ключевую информацию.
	2. Тест команда - люди которые что-то там делали.
	3. Описание процесса тестирования - что и как тест команда делала.
	4. Расписание - когда и сколько времени у кого ушло на выполнение какой-то задачи
	5. Статистика по новым обнаруженным дефектам - таблица, сколько и какие дефекты были найдены за период. К ней прилагается список найденных за период дефектов с ID важностью и саммари.
	6. Общая статистика за ВСЕ дефекты с момента запуска проекта.
	7. Рекомендации - обычно пишут серьезные мысли и решения об изменениях, например изменение тимы, графика.
	8. Аттачменты - секция с данными в доках, логах, рисунках, графах.
	
	

	АВТОМАТИЗАЦИЯ ТЕСТИРОВАНИЯ - набор средств и подходов для того чтобы хотя бы частично исключить человека из тестирования.
	Фреймворки автоматизации тестирования - инструмент(или библиотека) который предоставляет среду для автоматизации тестирования.
	Тест харнесс - среда из драйверов нужных для запуска теста.
	В классическом тестировании быстро разрабатывается тест и очень долго выполняется. В автоматизированном - наоборот.
	Решение об автоматизации зависит от:
	1. время
	2. сколько раз тест повторяется
	3. как легко будет адаптировать тест к изменениям
	4. Персонал
	Автоматизация быстрая, надежная, возможность выполнения тестов которые человек не может, удобное представление статистики, может выполнить низкоуровневые действия. НО! Нужны опытные люди, правильная стратегия, инструменты, из-за изменений в технологиях или требованиях может оказаться бесполезным.
	Она не особо заменяет мануальное тестирование.

	Области с эффективной автоматизацией тестирования:
	1. Автоматизация регрессионного тестирования  - куча итераций, можно не успеть делать в каждой одно и то же, поэтому несколько тестов автоматизируют.
	2. Тестирование с кучей разных окружений - много ОС, языковых систем, субд итд. Можно автоматизировать.
	3. Конфигурационное тестирование - в конфиге сто параметров, конфигов сто штук, все надо проверить, но можно автоматизировать.
	4. Много комбинаций входных данных - автоматизируем один процесс и просто даем ему разные данные.
	5. Модульное тестирование - проверки кусков кода
	6. Некоторые случаи интеграционного тестирования - много компонентов, все взаимодействуют, все с разными технологиями итд, создаются системы нахождения ошибок, но он сложный и для одного проекта.
	7. Базовое тестирование безопасности - есть ли пароли итд
	8. Тестирование производительности
	9. Автоматизация смоуктеста для крупных систем
	10. Приложения без человеческого интерфейса - субд, что-то серверное итд.
	11. Низкоуровневые операции - что приложение делает с сетью, как влияет итд.
	12. Длинные рутинные операции - регистрация пользователей итд
	13. Стандартная функциональность - присутствует во многих проектах (корзина, платежи итд)
	14. Классические хорошо автоматизированные области (мониторинг работы серверов, проверка ссылок, обновления) 
	ВРАГИ АВТОМАТИЗАЦИИ, ГДЕ НАДО БЫТЬ ОСТОРОЖНЫМ:
	1. Сложный пользовательский интерфейс
	2. Много разнообразных технологий которые нестабильны
	3. Вещи где очень важна реакция человека
	4. Нестабильные требования
	
	Идеи в области автоматизированного тестирования:
	1.Если тест рассчитан на автоматизацию, то его тесткейс будет содержать больше технической информации чем обычный.
	2. Так как могут быть использованы различные инструменты, стоит избегать в описании теста формулировок для конкретного инструмента или ОС.
	3. Так как автоматизированная система быстрее, нужно учесть тайминги и рассчитать периодические паузы.
	4. Никакого хардкодинга!
	5. ТОЛЬКО независимое выполнение автоматизированных тестов
	6. Автоматизация - это программирование, то есть правила те же.
	7. Понимай свой инструмент и что он должен делать.
	8. Действия != Проверки 
	9. Надо много много данных, часто берутся рандомные сгенеренные данные, надежные источники, реальные юзер данные или мануальная генерация.
	

	
	Технология "Записать и воспроизвести" - средство автоматизации, которое позволяет записать наши действия с тестируемым приложением. Результат получается в виде какого-то скриптового языка. Этот скрипт можно редактировать и улучшить самостоятельно, а затем многократно его выполнять. 
	Его плюсы:
	1. Она простая
	2. Быстрый скелет теста
	3. Собирает много технич. деталей
	4. Записывает рутинные действия
	Его минусы:
	1. Запись линейна, там нет циклов, if
	2. Записывается ВСЕ
	3. Хардкодинг, числа все тоже записываются
	4. Создаются странные непонятные имена которые потом переделывать
	
	Селениум IDE - интегрированная среда разработки для Селениум скриптов. Имплементирована как расширение Хрома и Фаерфокса, позволяет записывать, редачить, дебаггить тесты.
	Команды селениума:
	1. Действия - изменение стейта приложения (открыть,написать,кликнуть)
	2. Доступы - доступ к состоянию приложения и хранение результата в переменных(хранить)
	3. Проверки - сравнивают какие-то значения(верифай состояние редактирования, верифай какие-то данные). Есть ассерт и верифай - если первый провалится, весь тест аборт. Если дальнейшее выполнение имеет смысл - используем верифай.
	4. Управления - if while итд. 
	Для команд нужны таргеты. Таргеты состоят из локаторТип=локация.
	Локаторы:
	1. Контекстно-независимые - основываются на значения атрибутов элементов (айди, нейм, линктекст <a>, частичный линктекст <a>)
	2. Контекст-зависимые - основываются на структуре документа, если док изменен, то локатор обнаружить элемент не сможет.(css, xpath - иерархическая структура в XML документе как DOM дерево)

	СSS локаторы используют CSS селекторы чтобы находить элементы дока.
	1. Универсальный селектор (*) выбирает все элементы или все элементы внутри другого элемента.
	2. Селектор элементов выбирает все элементы с указанным именем
	3. Селектор класса (.класс) выбирает элементы с определенным атрибутом класса.
	4. id селектор (#) выбирает элементы с указанным id атрибутом.
	5. Селектор  атрибутов ([атрибут]) выбирает элементы с указанным атрибутом
	6. Селекторы потомков выбирает элементы внутри элементов на любой глубине.
	7. Селектор дочерних элементов (элемент>элемент) выбирает элементы на одном иерарх. уровне с указанным прямым родителем
	8. Селекторы немедленной последовательности (элемент1+элемент2) выбирает элемент2 который идет сразу после элемента1.
	9. Последователи-селекторы (элемент1~элемент2) выбирают все элементы2 после элемента1.
	10. Селекторы псевдоклассов (элемент:свойство) ищет элементы с указанным свойством.
	11. Селекторы псевдоэлементов (элемент:часть элемента, например p:first-letter.)

	XPATH локаторы:
	1. КАК ЛУЧШЕ ИХ ОПИСАТЬ - от искомого элемента идти вверх пока не найдется  элемент с id или уникальным классом который точно можно идентифицировать и от него отсылаться к искомому.